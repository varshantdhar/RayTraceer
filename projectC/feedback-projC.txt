;; Project C Guideline

;; _total-score_   65 /100

;; ====== correctness

;; Test A: Cube faces
;; cube data                            5 / 5

;; Test B: Cube Intersection
;; displays cube's front                / 5
;; displays at least one other side     5 / 5
;; displays all other sides             / 5
;; shadows                              / 5
;; position                             / 5

;; Test C:  map_texture_on_cube_faces
;; Same picture on every face           /10

;; Test D:  map_texture_around_cube
;; Look at sides - stripes only         / 5

;; Test E: Student's bitmap_from_file
;;                                      / 5

;; Test F: Shine
;; Sphere has shine                     10 /10
;; Shine is not in shadow                / 5

;; === correctness subtotal ===         20 /65

;; === style ===

;; development process                  15 /15


;; adequate tests                       0 / 4

;; well-written purposes                4 / 4
;; proper indentation, line breaks      4 / 4
;; well-named variables                 4 / 4

;; === efficiency ===
;; make sure to grade their test code for efficiency, as well
;; well-chosen control structures       4 / 4


;; _style_subtotal                      31 /35

;; === partial credit ===
;; They only earn points here for places where
;;  they earned 0 for correctness tests

;; test A
;; no partial credit

;; test B ;; intersect routine:
;; adjusts surface normal               / 3
;; adjusts d value                      / 3
;; 5 different tests                    5 / 5

;; test C
;; map_texture_on_cube_faces            5/ 5

;; test D
;; map_texture_around_cube              2/ 2
;; bitmap function implemented          2/ 2
;; shine implemented                    / 5
;; shine only occurs without shadow     / 2

;; partial_credit _subtotal_:	 	14

;; graded by Steven
testing if it compiles\n
clang -g -O3 -Wall -o rt xyz.c color.c ray.c sphere.c poster.c object.c obj_list.c scene.c light.c camera.c hit_test.c stage.c intersect.c raytracer.c rt.c texture.c cube.c -lm

#include "raytracer.h"

/*
typedef struct {
  location loc;
  unsigned int h;
  unsigned int w;
} camera;
*/

/* ===================================== */ 
/* === camera operations => camera.c === */ 
/* ===================================== */ 

const char *_cam_fmt = "camera(loc:%s,h:%u,w:%u)";

char *camera_tos(camera cm)
{
  char buf[128];
  memset(buf,0,128);
  char *loc = xyz_tos(cm.loc);
  snprintf(buf,128,_cam_fmt,loc,cm.h,cm.w);
  free(loc);
  return strdup(buf);
}

void camera_show(FILE *f, camera cm)
{
  char *s = camera_tos(cm);
  fprintf(f,"%s",s);
  free(s);
}
#include <string.h>
#include "raytracer.h"

/* =================================== */ 
/* === color operations => color.c === */ 
/* =================================== */ 

void _color_expr_check(char c, double x)
{
  if (x<0||x>1) {
    fprintf(stderr,"error (color_expr): %c out of range: %lf\n",c,x);
    exit(1);
  }
}

/* reject if any component is outside [0.0,1.0] */
color color_expr(double r, double g, double b)
{
  _color_expr_check('r',r);
  _color_expr_check('g',g);
  _color_expr_check('b',b);
  color c = {r,g,b};
  return c;
}

/* color_modulate : multiply the components of two colors */
/* (r,g,b) * (R,G,B) = (rR,gG,bB) */
color color_modulate(color c1, color c2)
{
  return color_expr(c1.r*c2.r,c1.g*c2.g,c1.b*c2.b);
}

/* _clamp : restrict x to [0,1] by clipping */
double _clamp(double x)
{
  return x<0?0:(x>1?1:x);
}

/* color_scale : scale each component by given scalar, but */
/* don't allow any component in the result to fall outside [0,1] */
color color_scale(double s, color c)
{
  return color_expr(_clamp(s*c.r),_clamp(s*c.g),_clamp(s*c.b));
}

/* add components of colors, but */
/* don't allow any component in the result to exceed 1 */
color color_add(color c1, color c2)
{
  return color_expr(_clamp(c1.r+c2.r),_clamp(c1.g+c2.g),_clamp(c1.b+c2.b));
}

const char *_color_fmt = "color(%lf,%lf,%lf)";

char *color_tos(color c)
{
  char buf[128];
  memset(buf,0,128);
  snprintf(buf,128,_color_fmt,c.r,c.g,c.b);
  return strdup(buf);
}

void color_show(FILE *f, color c)
{
  fprintf(f,_color_fmt,c.r,c.g,c.b);
}

unsigned char _byte(double x)
{
  return (unsigned char)(x*255.0);
}

/* color_show_bytes */
/* print three integers on [0,255] with spaces in between and a newline */
/* suitable for use in a PPM */
void color_show_bytes(FILE *f, color c)
{
  fprintf(f,"%u %u %u\n",_byte(c.r),_byte(c.g),_byte(c.b));
}

#include <stdio.h>
#include <string.h>
#include "raytracer.h"

/* ===================================== */ 
/* === cube operations => cube.c === */ 
/* ===================================== */ 

/* cube_expr : construct a cube record,
 * setting object pointer to NULL (unused in this implementation)
 * and texture to NULL (future expansion)
 */
cube cube_expr(location ftl, 
		   double l, 
		   color(*sc)(object *,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (sphere_expr): malloc failed\n");
    exit(1);
  }
  new_obj->tag = CUBE;
  new_obj->o.c.front_top_left = ftl;
  new_obj->o.c.length = l;
  new_obj->o.c.surface_color = sc;
  new_obj->o.c.shine = sh;
  new_obj->o.c.o = NULL;
  new_obj->t = NULL; // texture reserved for project B
  return new_obj->o.c;
}

const char *_cub_fmt =
  "cube(\n  front-top-left:%s\n  length:%lf\n  surface_color:<FN@%p>\n"
   "  shine:%s\n  object:%p\n)";

char *cube_tos(cube c)
{
  char buf[1024];
  memset(buf,0,1024);
  char *ctr = xyz_tos(c.front_top_left);
  char *shn = color_tos(c.shine);
  snprintf(buf,1024,_cub_fmt,ctr,c.length,c.surface_color,shn,c.o);
  free(ctr);
  free(shn);
  return strdup(buf);
}

void cube_show(FILE *f, cube c)
{
  char *t = cube_tos(c);
  fprintf(f,"%s",t);
  free(t);
}
#include "raytracer.h"

/*
typedef struct {
  enum {MISS=0,HIT=1} miss;
  double t;
  location hit_point;
  color surf; // not used in project A
  color shine; // not used in project A
  direction surf_norm; // not used in project A
} hit_test;
*/

/* ========================================= */ 
/* === hit_test operations => hit_test.c === */ 
/* ========================================= */ 

const char *_hit_test_fmt = 
  "hit_test(\n  t:%lf\n  hit_point:%s\n  surf:%s\n  shine:%s\n  surf_norm:%s\n)";

char *hit_test_tos(hit_test t)
{
  if (t.miss==MISS)
    return strdup("MISS");
  char buf[1024];
  memset(buf,0,1024);
  char *shp = xyz_tos(t.hit_point);
  char *srf = color_tos(t.surf);
  char *shn = color_tos(t.shine);
  char *nrm = xyz_tos(t.surf_norm);
  snprintf(buf,1024,_hit_test_fmt,t.t,shp,srf,shn,nrm);
  free(shp);
  free(srf);
  free(shn);
  free(nrm);  
  return strdup(buf);
}

void hit_test_show(FILE *f, hit_test t)
{
  char *s = hit_test_tos(t);
  fprintf(f,"%s",s);
  free(s);
}
#include <math.h>
#include "raytracer.h"

/* === intersect.c === */

/* to fill in slots not used in project A */
color _c0 = {0,0,0};
xyz   _v0 = {0,0,0};

hit_test sph_int(ray r, sphere s)
{
  xyz A = xyz_sub(r.origin,s.center);
  double B = xyz_dot(A,r.dir);
  double C = xyz_dot(A,A)-s.radius*s.radius;
  double D = B*B-C;
  double t = (-B)-sqrt(D);
  if (D>0&&t>0) {
    hit_test ht = {HIT,t,ray_position(r,t),_c0,s.shine,_v0};
	xyz v = xyz_sub(ray_position(r,t), s.center);
	ht.surf_norm = xyz_norm(v);
    return ht;
  } else {
    // if it doesn't hit, then it's a miss, and nothing else in the struct matters
    hit_test ht = {MISS,0,_v0,_c0,_c0,_v0};
    return ht;
  }
}

/* pre: the location's z matches the poster's */
/* (this is an outcome of the math given)     */
int on_poster(poster *p, location loc)
{
  return (loc.x>=p->upper_left.x) &&
         (loc.x<=(p->upper_left.x+p->w)) &&
         (loc.y<=p->upper_left.y) &&
         (loc.y>=(p->upper_left.y-p->h)) &&
		 (loc.z>=p->upper_left.z) &&
		 (loc.z<=(p->upper_left.z+p->h));
}

hit_test pst_int(ray r, poster p, xyz n, double d)
{
  double t = -(xyz_dot(r.origin,n)+d)/xyz_dot(r.dir,n);
  location hp = ray_position(r,t);
  if (t>0&&on_poster(&p,hp)) {
    hit_test ht = {HIT, t, hp, {0,0,0}, p.shine, n};
    return ht;
  } 
  hit_test ht = {MISS,0,{0,0,0},{0,0,0},{0,0,0},{0,0,0}};
  return ht; 
}


hit_test cube_int(ray r, cube c)
{
	poster p;
	p.w = c.length;
	p.h = c.length;
	p.upper_left = c.front_top_left;
	location corner = c.front_top_left;
	double length = c.length;
	hit_test ht = pst_int(r,p,xyz_expr(0,0,-1),p.upper_left.z);
	//Face
	if(ht.miss == HIT)
		return ht;
	corner = xyz_expr(corner.x + length, corner.y, corner.z);
	p.upper_left = corner;
	//Right Side
	ht = pst_int(r,p,xyz_expr(1,0,0),-p.upper_left.x);
	if(ht.miss == HIT)
		return ht;
	p.upper_left = c.front_top_left;
	//Left Side
	ht = pst_int(r,p,xyz_expr(-1,0,0),p.upper_left.x);
	if(ht.miss == HIT)
		return ht;
	//Top
	ht = pst_int(r,p,xyz_expr(0,1,0),-p.upper_left.y);
	if(ht.miss == HIT)
		return ht;
	corner = xyz_expr(c.front_top_left.x ,c.front_top_left.y - length, c.front_top_left.z); 
	p.upper_left = corner;
	//Bottom
	ht = pst_int(r,p,xyz_expr(0,-1,0),p.upper_left.y);
	return ht;
}

hit_test intersect(ray r, object obj)
{
  switch (obj.tag) {
  case SPHERE:
    return sph_int(r,obj.o.s);
  case POSTER:
    return pst_int(r,obj.o.p, xyz_expr(0,0,-1), obj.o.p.upper_left.z);
  case CUBE:
	return cube_int(r,obj.o.c);	
  default:
    fprintf(stderr,"error (intersect): unknown object tag %d\n",obj.tag);
    exit(1);
  }
}
/* reserved for project B */
#include "raytracer.h"

/* ===================================== */ 
/* === object operations => object.c === */ 
/* ===================================== */ 

char *object_tos(object o)
{
  char buf[1024];
  memset(buf,0,1024);
  char *s;
  switch (o.tag) {
  case SPHERE:
    s = sphere_tos(o.o.s);
    break;
  case POSTER:
    s = poster_tos(o.o.p);
    break;
  case CUBE:
  	s = cube_tos(o.o.c);
  	break;
  default:
    fprintf(stderr,"error (object_tos): unexpected tag in object %d",o.tag);
    exit(1);
  }
  snprintf(buf,1024,"object[\n%s,\n  texture:%p\n]",s,o.t);
  free(s);
  return strdup(buf);    
}

void object_show(FILE *f, object o)
{
  char *s = object_tos(o);
  fprintf(f,"%s",s);
  free(s);
}
#include <string.h>
#include "raytracer.h"

/* ======================================*/ 
/* === object list ops => obj_list.c === */ 
/* ======================================*/ 

obj_list *ol_cons(object o, obj_list *os)
{
  obj_list *new_list = (obj_list*)malloc(sizeof(obj_list));
  if (new_list==NULL) {
    fprintf(stderr,"error (ol_cons): malloc failed\n");
    exit(1);
  }
  new_list->obj = o;
  new_list->next = os;
  return new_list;
}

obj_list *ol_singleton(object s)
{
  return ol_cons(s,NULL);
}

/* helper function to concatenate three strings */
char *_cat3(char *s1, char *s2, char *s3)
{
  int i;
  unsigned int len1 = strlen(s1);
  unsigned int len2 = strlen(s2);
  unsigned int len3 = strlen(s3);
  char *s4 = (char*)malloc(len1+len2+len3+1);
  for (i=0; i<len1; i++)
    s4[i] = s1[i];
  for (i=0; i<len2; i++)
    s4[len1+i] = s2[i];
  for (i=0; i<len3; i++)
    s4[len1+len2+i] = s3[i];
  s4[len1+len2+len3]='\0';
  return s4;
}

char *ol_tos(obj_list *os)
{
  char *s = strdup("obj_list[");
  char *t = strdup("");
  while (os) {
    char *o = object_tos(os->obj);
    t = s;
    s = _cat3(s,o,os->next?":":"");
    os=os->next;
    free(o);
    free(t);
  }
  t = s;
  s = _cat3(s,"]","");
  free(t);
  return s;
}

void ol_show(FILE *f, obj_list *os)
{
  char *s = ol_tos(os);
  fprintf(f,"%s",s);
  free(s);
}

void ol_free(obj_list *ss)
{
  if (ss) {
    ol_free(ss->next);
    free(ss);
  }
}
#include "raytracer.h"

/* ======================================= */ 
/* === poster operations => poster.c ===== */ 
/* ======================================= */ 

/* poster_expr : construct a poster record,
 * setting object pointer to NULL (unused in this implementation)
 * and texture to NULL (future expansion)
 */
poster poster_expr(location ulc, 
		   double w, 
		   double h, 
		   color(*sc)(object*,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (poster_expr): malloc failed\n");
    exit(1);
  }
  if (w<0) {
    fprintf(stderr,"error (poster_expr): negative w: %lf\n",w);
    exit(1);
  }
  if (h<0) {
    fprintf(stderr,"error (poster_expr): negative h: %lf\n",w);
    exit(1);
  }
  new_obj->tag = POSTER;
  new_obj->o.p.upper_left = ulc;
  new_obj->o.p.w = w;
  new_obj->o.p.h = h;
  new_obj->o.p.surface_color = sc;
  new_obj->o.p.shine = sh;
  new_obj->o.p.o = NULL;
  new_obj->t = NULL; // texture reserved for project B
    
  return new_obj->o.p;
}

const char *_pst_fmt =
  "poster(\n  upper_left:%s\n  w:%lf\n  h:%lf\n  surface_color:<FN@%p>\n  shine:%s\n  object:%p\n)";

char *poster_tos(poster s)
{
  char buf[1024];
  memset(buf,0,1024);
  char *ulc = xyz_tos(s.upper_left);
  char *shn = color_tos(s.shine);
  snprintf(buf,1024,_pst_fmt,ulc,s.w,s.h,s.surface_color,shn,s.o);
  free(ulc);
  free(shn);
  return strdup(buf);
}

void poster_show(FILE *f, poster s)
{
  char *t = poster_tos(s);
  fprintf(f,"%s",t);
  free(t);
}
#include "raytracer.h"

/* =============================== */ 
/* === ray operations => ray.c === */ 
/* =============================== */ 

/* see web page for ray_position code */
xyz ray_position(ray r, double t)
{
  return xyz_add(r.origin, xyz_scale(t, r.dir));
}

const char *_ray_fmt = "ray(origin:%s,dir:%s)";

char *ray_tos(ray r)
{
  char buf[256];
  memset(buf,0,256);
  char *ost = xyz_tos(r.origin);
  char *dst = xyz_tos(r.dir);
  snprintf(buf,256,_ray_fmt,ost,dst);
  free(ost);
  free(dst);
  return strdup(buf);
}

void ray_show(FILE *f, ray r)
{
  char *s = ray_tos(r);
  fprintf(f,"%s",s);
  free(s);
}


#include "raytracer.h"

/* === raytracer.c === */

/* hit test utilities */

const hit_test _miss = {MISS,0,{0,0,0},{0,0,0},{0,0,0},{0,0,0}};

int hit(hit_test t)
{
  return t.miss==HIT;
}

int miss(hit_test t)
{
  return t.miss==MISS;
}

/* coordinate system transformation */

location logical_loc(camera c, unsigned int x, unsigned int y)
{
  double pixw, pixh;
  double lx, ly;
  if (c.h>c.w)
    pixh = pixw = 2.0 / c.h;
  else
    pixh = pixw = 2.0 / c.w;
  if (x>c.w || y>c.h) {
    fprintf(stderr, "error (logical_loc): out of bounds (%d, %d)\n", x, y);
    exit(1);
  }
  lx = -1.0 + (pixw * x) + (pixw / 2.0);
  ly =  1.0 - ((pixh * y) + (pixh / 2.0));
  if (c.w>c.h)
    ly -= (c.w-c.h) / 2.0 * pixh;
  else
    lx += (c.h-c.w) / 2.0 * pixw;
  location result = {lx, ly, 0};
  return result;
}

/* ray tracing */

color color_at(object *obj, location loc)
{
	color(*sc)(object*,location) =
		obj->tag == SPHERE ?
		obj->o.s.surface_color:
		obj->tag == CUBE ?
		obj->o.c.surface_color:
    	obj->o.p.surface_color;
  	return (*sc)(obj,loc);
}

color trace_ray(scene s, ray r)
{
  obj_list *objs = s.objects;
  hit_test closest_hit = _miss;
  object *closest_obj = NULL;
  /* walk over object list, keep track of closest object if there is one */
  while (objs) {
    /* for each object, check for intersect */
    hit_test curr_hit = intersect(r,objs->obj);
    /* if it hits AND it's the first hit OR it's closer than closest hit */
    if (hit(curr_hit) && (miss(closest_hit) || (curr_hit.t<closest_hit.t))) {
      // update this to be the closest hit
      closest_hit = curr_hit;
	  closest_hit.surf = color_at(&(objs->obj), curr_hit.hit_point);
      closest_obj = &(objs->obj);
    }
    // advance to next object
    objs = objs->next;
  }
  /* if there is a closest object, return its color, otherwise s.bg */
  //return closest_obj?color_at(closest_obj,closest_hit.hit_point):s.bg;
  return lighting(s,r,closest_hit);
}

/* main loop and ppm creation */

void ppm_header(FILE *f, int height, int width)
{
  fprintf(f,"P3\n");
  fprintf(f,"%d %d\n", width, height);
  fprintf(f,"255\n");
}

void render(FILE *f, stage g)
{
  int row, col;
  camera c = g.c;
  scene sc = g.s;
  ppm_header(f,c.h,c.w);
  /* loop over all locations in the pixel field */
  for(row=0; row<c.h; row++) {
    for(col=0; col<c.w; col++) {
      /* 1: Translate from physical to logical */
      location loc = logical_loc(c,col,row);
      /* 2: Create a directional vector from camera to pixel */
      direction dir = xyz_sub(loc,c.loc);
      /* 3: Normalize this vector */
      direction normdir = xyz_norm(dir);
      /* 4: Create a ray starting at the camera in the direction of normdir */
      ray r = {c.loc,normdir};
      /* 5: trace the ray through the scene and obtain the color */
      color col = trace_ray(sc,r);
      /* 6: print that pixel to the screen (which can be redirected to a file) */
      color_show_bytes(f,col);
    }
  }
}
	

int shadow(location p, light l, obj_list *objs)
{
	ray nray;
	hit_test test;
	direction nudge = xyz_scale(0.0001, l.dir);
	location lifted = xyz_add(p, nudge);
	nray.origin = lifted;
	nray.dir = l.dir;
	
	obj_list *tmp = (obj_list *)malloc(sizeof(obj_list));
	for(tmp = objs; tmp != NULL; tmp = tmp->next){
		test = intersect(nray, tmp->obj);
		if(test.miss == HIT){
			return 1;
		}
	}
	return 0;
}


color check_rgb(color c)
{
	c.r = (c.r > 1.0) ? 1.0 : c.r;
	c.g = (c.g > 1.0) ? 1.0 : c.g;
	c.b = (c.b > 1.0) ? 1.0 : c.b;
	return c;
}


color shine(scene s, ray r, hit_test h)
{
	direction n = h.surf_norm;
	double f;
	direction l = xyz_scale(1/xyz_mag(s.light.dir), s.light.dir);
	color sh = h.shine;
	direction rr = xyz_sub(xyz_scale(2 * xyz_dot(n, l), n), l);
	direction v = xyz_neg(r.dir);
	if (xyz_dot(n, l) > 0){
		if (xyz_dot(rr, v) > 0){
			f = xyz_dot(rr,v)*xyz_dot(rr,v)*xyz_dot(rr,v)*xyz_dot(rr,v)*xyz_dot(rr,v)*xyz_dot(rr,v);
			return check_rgb(color_scale(f, sh));
		} else {
			return color_expr(0.0, 0.0, 0.0);
		}
	}
 	else
		return color_expr(0,0,0);
		
}

color lighting(scene s, ray r, hit_test h)
{
	double max;
	color dcolor, f;
	if(h.miss == MISS) 
		return s.bg;
	else {
		int n = shadow(h.hit_point, s.light, s.objects);
		//printf("H SURF: %s", color_tos(h.surf));
		if(n == 1){
			return color_modulate(h.surf, s.amb);
		} else { 
			//printf("LIGHT\n");
			max = xyz_dot(h.surf_norm, s.light.dir);
			max = (max > 0.0) ? max : 0.0;
			dcolor = color_scale(max ,s.light.c);
			f = color_modulate(h.surf, color_add(dcolor, s.amb));
			return color_add(shine(s,r,h), f);
		}
	}		
}	
#include "raytracer.h"

int main(int argc, char *argv[])
{
  int sel = 7;
  stage stg = get_stage(sel);
  render(stdout,stg);
  stage_show(stderr,stg);

  ol_free(stg.s.objects);

  return 0;
}

#include "raytracer.h"

/*
typedef struct {
  color bg;
  obj_list *objects;
  light light; // not used in project A
  color amb; // not used in project A
} scene;
*/

/* =================================== */ 
/* === scene operations => scene.c === */ 
/* =================================== */ 

const char *_scene_fmt = 
  "--- begin scene\nbg:    %s\nlight: (unused)\namb:   (unused)\n"
  "objs:  %s\n--- end scene\n";

char *scene_tos(scene sc)
{
  char buf[1024];
  memset(buf,0,1024);
  char *bgs  = color_tos(sc.bg);
  char *os   = ol_tos(sc.objects);
  snprintf(buf,1024,_scene_fmt,bgs,os);
  char *result = strdup(buf);
  free(bgs);
  free(os);
  return result;
}

void scene_show(FILE *f, scene sc)
{
  char *s = scene_tos(sc);
  fprintf(f,"%s",s);
  free(s);
}
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

/* ===================================== */ 
/* === sphere operations => sphere.c === */ 
/* ===================================== */ 

/* sphere_expr : construct a sphere record,
 * setting object pointer to NULL (unused in this implementation)
 * and texture to NULL (future expansion)
 */
sphere sphere_expr(location v, 
		   double r, 
		   color(*sc)(object *,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (sphere_expr): malloc failed\n");
    exit(1);
  }
  new_obj->tag = SPHERE;
  new_obj->o.s.center = v;
  new_obj->o.s.radius = r;
  new_obj->o.s.surface_color = sc;
  new_obj->o.s.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = NULL; // texture reserved for project B
  return new_obj->o.s;
}

const char *_sph_fmt =
  "sphere(\n  center:%s\n  radius:%lf\n  surface_color:<FN@%p>\n"
   "  shine:%s\n  object:%p\n)";

char *sphere_tos(sphere s)
{
  char buf[1024];
  memset(buf,0,1024);
  char *ctr = xyz_tos(s.center);
  char *shn = color_tos(s.shine);
  snprintf(buf,1024,_sph_fmt,ctr,s.radius,s.surface_color,shn,s.o);
  free(ctr);
  free(shn);
  return strdup(buf);
}

void sphere_show(FILE *f, sphere s)
{
  char *t = sphere_tos(s);
  fprintf(f,"%s",t);
  free(t);
}
#include "raytracer.h"

/* =================================== */ 
/* === stage operations => stage.c === */ 
/* =================================== */ 

const char *_stage_fmt = "*** begin stage\n\n%s\n\n%s\n*** end stage\n";

char *stage_tos(stage stg)
{
  char buf[1024];
  memset(buf,0,1024);
  char *c = camera_tos(stg.c);
  char *s = scene_tos(stg.s);
  snprintf(buf,1024,_stage_fmt,c,s);
  free(c);
  free(s);
  return strdup(buf);
}

void stage_show(FILE *f, stage stg)
{
  char *s = stage_tos(stg);
  fprintf(f,"%s",s);
  free(s);
}

/* constant coloring functions for easy testing */

color sc_red(object *o, location loc)
{
  return color_expr(1,0,0);
}

color sc_green(object *o, location loc)
{
  return color_expr(0,1,0);
}

/* sc_blue : surface color function that returns blue, always */
color sc_blue(object *o, location loc)
{
  return color_expr(0,0,1);
}

/* sc_maroon : surface color function that returns maroon, always */
color sc_maroon(object *o, location loc)
{
  return color_expr(0.5,0,0);
}

color sc_purple(object *o, location loc)
{
  return color_expr(0.5,0,0.5);
}

color sc_gray(object *o, location loc)
{
  return color_expr(0.5,0.5,0.5);
}

/* coloring functions specified on web page */

/* _dist : compute Euclidean distance in 3-space */
double _dist(xyz a, xyz b)
{
  double dx = a.x-b.x;
  double dy = a.y-b.y;
  double dz = a.z-b.z;
  return sqrt(dx*dx+dy*dy+dz*dz);
}

/* poster_red_distance - calculate distance from upper-left-corner, use to 
 * scale from black at upper-left to red at lower-right
 */
color poster_red_distance(object *o, location loc)
{
  if (o->tag!=POSTER) {
    fprintf(stderr,"error (poster_red_distance): not a poster\n");
    exit(1);
  }
  location ulc = o->o.p.upper_left;
  /* compute lower right corner */
  location lrc = {ulc.x+o->o.p.w,ulc.y+o->o.p.h,ulc.z}; 
  /* take the distance from between loc and ulc, and divide by total distance
   * from the ulc to rlc. place that result as the red in a color.
   */
  return color_expr(_dist(ulc,loc)/_dist(ulc,lrc),0,0);
}

/* poster_rgb_distance - calculate distance from upper-left-corner, use to 
 * scale from all red at upper-left to all blue at lower-left, with 
 * green in the middle, and gradations between them.
 */
color poster_rgb_distance(object *o, location loc)
{
  if (o->tag!=POSTER) {
    fprintf(stderr,"error (poster_rgb_distance): not a poster\n");
    exit(1);
  }
  location ulc = o->o.p.upper_left;
  /* compute lower right corner */
  location lrc = {ulc.x+o->o.p.w,ulc.y+o->o.p.h,ulc.z}; 
  /* relative ratio within poster */
  double ratio = _dist(ulc,loc)/_dist(ulc,lrc);
  /* for the first half, we blend from red to green */
  if (ratio<=0.5)
    return color_expr(1-ratio*2,ratio*2,0);
  /* for the first half, we blend from green to blue */
  else 
    return color_expr(0,2*(1-ratio),2*ratio-1);
}


/* sphere_loc_to_rgb - scale the location so that it maps x, y, z onto r, g, b in 
 * a way that shows gradations in the sphere. You are being given flexibility to 
 * do this in a way that looks interesting to you.
 */
/* Note: Yours does NOT need to be exactly like this - this is one solution */
color sphere_loc_to_rgb(object *o, location loc)
{
  // separately find relative x, y, z (relative to sphere),                                           
  // then map onto 0->1 or r, g, b                                                                    
  sphere *s = &(o->o.s);

  // 0 to 1 - where are x and y within poster?                                                        
  double x_within_sphere = (s->center.x+s->radius - loc.x)/
    (s->radius*2);
  double y_within_sphere = (s->center.y+s->radius - loc.y)/
    (s->radius*2);
  double z_within_sphere = (s->center.z+s->radius - loc.z)/
    (s->radius*2);

  return color_expr(x_within_sphere, y_within_sphere, z_within_sphere);

}

/* sphere_stripes - color the sphere with 4 blue stripes on a white background.
 * the pattern is: WBWBWBWBW. The stripes and background are roughly equal height.
 */
color sphere_horiz_stripes(object *o, location loc)
{
  if (o->tag!=SPHERE) {
    fprintf(stderr,"error (sphere_horiz_stripes): not a sphere\n");
    exit(1);
  }    
  location ctr = o->o.s.center;
  double rad = o->o.s.radius;
  double dy = loc.y-ctr.y;
  double s = (dy+rad)/(2*rad); /* s is on [0,1] */
  int n = (int)floor(s*9);     /* n is on [0,9] */
  if (n==9) n--;               /* n is on [0,8] */
  return n%2?color_expr(0,0,1):color_expr(1,1,1);
}


/* object constructors */

object *sphere_obj(location v, double r, color(*sc)(object*,location), color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (sphere_obj): malloc failed\n");
    exit(1);
  }
  new_obj->tag = SPHERE;
  new_obj->o.s.center = v;
  new_obj->o.s.radius = r;
  new_obj->o.s.surface_color = sc;
  new_obj->o.s.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = NULL;
  return new_obj;
}

object *sphere_text(location v, double r, color(*sc)(object*,location), texture *t, color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (sphere_obj): malloc failed\n");
    exit(1);
  }
  new_obj->tag = SPHERE;
  new_obj->o.s.center = v;
  new_obj->o.s.radius = r;
  new_obj->o.s.surface_color = sc;
  new_obj->o.s.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = t;
  return new_obj;
}

object *poster_obj(location ulc, 
		   double w,
		   double h, 
		   color(*sc)(object*,location), 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (poster_obj): malloc failed\n");
    exit(1);
  }
  new_obj->tag = POSTER;
  new_obj->o.p.upper_left = ulc;
  new_obj->o.p.w = w;
  new_obj->o.p.h = h;
  new_obj->o.p.surface_color = sc;
  new_obj->o.p.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = NULL;
  return new_obj;
}

object *poster_text(location ulc, 
		   double w,
		   double h, 
		   color(*sc)(object*,location),
		   texture *t, 
		   color sh)
{
  object *new_obj = (object*)malloc(sizeof(object));
  if (new_obj==NULL) {
    fprintf(stderr,"error (poster_obj): malloc failed\n");
    exit(1);
  }
  new_obj->tag = POSTER;
  new_obj->o.p.upper_left = ulc;
  new_obj->o.p.w = w;
  new_obj->o.p.h = h;
  new_obj->o.p.surface_color = sc;
  new_obj->o.p.shine = sh;
  new_obj->o.s.o = NULL;
  new_obj->t = t;
  return new_obj;
}

object *cube_obj(location ftl, double l, color(*sc)(object *, location), color sh)
{
    object *new_obj = (object*)malloc(sizeof(object));
    if (new_obj==NULL) {
      fprintf(stderr,"error (poster_obj): malloc failed\n");
      exit(1);
    }
    new_obj->tag = CUBE;
    new_obj->o.c.front_top_left = ftl;
    new_obj->o.c.length = l;
    new_obj->o.c.surface_color = sc;
    new_obj->o.c.shine = sh;
    new_obj->o.c.o = NULL;
    new_obj->t = NULL;
    return new_obj;
}

object *cube_text(location ftl, double l, color(*sc)(object *, location), texture *t, color sh)
{
    object *new_obj = (object*)malloc(sizeof(object));
    if (new_obj==NULL) {
      fprintf(stderr,"error (poster_obj): malloc failed\n");
      exit(1);
    }
    new_obj->tag = CUBE;
    new_obj->o.c.front_top_left = ftl;
    new_obj->o.c.length = l;
    new_obj->o.c.surface_color = sc;
    new_obj->o.c.shine = sh;
    new_obj->o.c.o = NULL;
    new_obj->t = t;
    return new_obj;
}

/* The function get_stage just needs to return a valid stage. */
/* The argument may be used, or not, at your discretion. */
stage get_stage(unsigned int selection)
{
  if (selection==1) {
    /* gallery image 1 */
    camera cam = {{0,0,-5},120,120};
    location ulc = {-1.5,1.5,4.5};
    object *pst = poster_obj(ulc,3,3,&poster_red_distance,color_expr(0,0,0));
    scene scn = {{0,0,0.25},ol_singleton(*pst)};
    /* valgrind caught this -- it's because the poster is copied into
     * the object list, as opposed to its pointer being copied
     */
    free(pst);
    stage stg = {cam,scn};
    return stg;
  }
  if (selection==2) {
    /* gallery image 2 */
    camera cam = {{0,0,-5},120,120};
    location ulc = {-1.5,1.5,4.5};
    object *pst = poster_obj(ulc,3,3,&poster_rgb_distance,color_expr(0,0,0));
    scene scn = {{0,0,0.25},ol_singleton(*pst)};
    free(pst);
    stage stg = {cam,scn};
    return stg;
  }
  if (selection==3) {
    /* gallery image 3 */
    camera c = {{0,0,-5},120,120};
    object *sph = sphere_obj(xyz_expr(1,0,4),1,&sphere_loc_to_rgb,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  }
  if (selection==4) {
    /* gallery image 4 */
    camera c = {{0,0,-5},120,120};
    object *sph0 = sphere_obj(xyz_expr(0,0,3),1,&sphere_loc_to_rgb,color_expr(0,0,0));
    object *sph1 = sphere_obj(xyz_expr(-0.5,0.7,3),0.5,&sc_purple,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_cons(*sph0,ol_singleton(*sph1));
    free(sph0);
    free(sph1);
    stage g = {c,s};
    return g;
  } 
  
  if (selection==5){
	  camera c ={{0,0,-5},120,120};
	  object *cub0 = cube_obj(xyz_expr(-1.3,0.55,1),1.5,&sc_blue,color_expr(1,1,1));
	  scene s = {{0,0,0.25}, NULL};
	  s.objects = ol_singleton(*cub0);
	  free(cub0);
	  stage g = {c, s};
	  return g;
  }
  
  if (selection==6){
	  light l; 
	  color amb;
	  l.dir = xyz_expr(-0.58, 0.58, -0.58);
	  l.c = color_expr(1,1,1);
	  amb = color_expr(0.1, 0.1, 0.1);
	  camera c = {{0,0,-5}, 120, 120};
	  texture *func = make_waves(100,0,0,color_expr(1, 0, 0));
	  object *cub0 = cube_text(xyz_expr(-1.3,0.55,0),1.5,&map_texture_around_cube,func,color_expr(1,1,1));
	  scene s = {{0,0,0.25}, ol_singleton(*cub0), l, amb};
	  free(cub0);
	  stage g = {c, s};
	  return g;
  }
  
  if (selection==7){
	  light l; 
	  color amb;
	  l.dir = xyz_expr(-0.58, 0.58, -0.58);
	  l.c = color_expr(1,1,1);
	  amb = color_expr(0.1, 0.1, 0.1);
	  camera c = {{0,0,-5}, 120, 120};
	  texture *func = make_waves(100,0,0,color_expr(1, 0, 0));
	  object *cub0 = cube_text(xyz_expr(-1.3,0.55,0),1.5,&map_texture_on_cube_faces,func,color_expr(1,1,1));
	  scene s = {{0,0,0.25}, ol_singleton(*cub0), l, amb};
	  free(cub0);
	  stage g = {c, s};
	  return g;
  }
  
  if (selection==45){
	  camera c ={{0,0,-5},120,120};
	  object *sph0 = sphere_text(xyz_expr(0,0,3),1,&map_texture_on_sphere,make_bitmap_from_file("test.ppm"),color_expr(0,0,0));
	  scene s = {{0,0,0.25}, NULL};
	  s.objects = ol_singleton(*sph0);
	  free(sph0);
	  stage g = {c, s};
	  return g;
  }

  
  if (selection == 50) {
	 
	  light l; 
	  color amb;
	  l.dir = xyz_expr(-0.58, 0.58, -0.58);
	  l.c = color_expr(1,1,1);
	  amb = color_expr(0.1, 0.1, 0.1);
	  camera c = {{0,0,-5}, 120, 120};
	  texture *func = make_vert_stripes(color_expr(0.5, 0.5, 0.8), color_expr(0.9, 0, 0), 7);
	  object *sph = sphere_text(xyz_expr(0,0,3),1,&map_texture_on_sphere,func,color_expr(1,1,1));
	  scene s = {{0, 0, 0.25}, ol_singleton(*sph), l, amb};
	  free(sph);
	  stage g = {c, s};
	  return g;
	  
  }
  
  if (selection == 51) {
	 
	  light l; 
	  color amb;
	  l.dir = xyz_expr(-0.58, 0.58, -0.58);
	  l.c = color_expr(1,1,1);
	  amb = color_expr(0.1, 0.1, 0.1);
	  camera c = {{0,0,-5}, 120, 120};
	  texture *func = make_horiz_stripes(color_expr(0.5, 0.5, 0.8), color_expr(0.9, 0, 0), 7);
	  object *sph = sphere_text(xyz_expr(0.5,0.7,3),0.5,&map_texture_on_sphere,func,color_expr(1,1,1));
	  scene s = {{0, 0, 0.25}, ol_singleton(*sph), l, amb};
	  free(sph);
	  stage g = {c, s};
	  return g;
	  
  }
  
  if (selection == 52) {
	 
	  light l; 
	  color amb;
	  l.dir = xyz_expr(-0.58, 0.58, -0.58);
	  l.c = color_expr(1,1,1);
	  amb = color_expr(0.1, 0.1, 0.1);
	  camera c = {{0,0,-5}, 120, 120};
	  texture *func = make_horiz_stripes(color_expr(0.5, 0.5, 0.8), color_expr(0.9, 0, 0), 7);
	  object *sph = sphere_text(xyz_expr(0.5,0.7,3),0.5,&map_texture_on_sphere,func,color_expr(0.2,0.3,0.1));
	  scene s = {{0, 0, 0.25}, ol_singleton(*sph), l, amb};
	  free(sph);
	  stage g = {c, s};
	  return g;
	  
  }
  
  if (selection == 53) {
	 
	  light l; 
	  color amb;
	  l.dir = xyz_expr(-0.58, 0.58, -0.58);
	  l.c = color_expr(1,1,1);
	  amb = color_expr(0.1, 0.1, 0.1);
	  camera c = {{0,0,-5}, 120, 120};
	  texture *func = make_waves(100,0,0,color_expr(1, 0, 0));
	  object *pst = poster_text(xyz_expr(-1.5,1.5,4.5),3,3,&map_texture_on_poster,func,color_expr(0,0,0));
	  scene s = {{0, 0, 0.25}, ol_singleton(*pst), l, amb};
	  free(pst);
	  stage g = {c, s};
	  return g;
	  
  }
  if (selection==100) {
    /* striped sphere */
    camera c = {{0,0,-5},120,120};
    object *sph = sphere_obj(xyz_expr(0,0,4),1,&sphere_horiz_stripes,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==101) {
    /* let's get a better look at the striped sphere... */
    camera c = {{0,0,-5},500,800};
    object *sph = sphere_obj(xyz_expr(0,0,4),1,&sphere_horiz_stripes,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==103) {
    /* based on gallery image 3 */
    camera c = {{0,0,-5},120,120};
    object *sph = sphere_obj(xyz_expr(1,0,4),1,&sc_red,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==104) {
    /* based on gallery image 4 */
    camera c = {{0,0,-5},120,120};
    object *sph0 = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    object *sph1 = sphere_obj(xyz_expr(-0.5,0.7,3),0.5,&sc_red,color_expr(0,0,0));
    scene s = {{0,0,0.25},NULL};
    s.objects = ol_cons(*sph0,ol_singleton(*sph1));    
    free(sph0);
    free(sph1);
    stage g = {c,s};
    return g;
  }

  /* some simple examples for students */
  if (selection==15200) {
    camera c = {{0,0,-5},300,300};
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==15201) {
    camera c = {{0,0,-5},600,300};
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==15202) {
    camera c = {{0,0,-5},300,600};
    object *sph = sphere_obj(xyz_expr(0,0,3),1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*sph);
    free(sph);
    stage g = {c,s};
    return g;
  } 
  if (selection==15203) {
    camera c = {{0,0,-5},300,300};
    object *pst = poster_obj(xyz_expr(-1,1,3),1,1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*pst);
    free(pst);
    stage g = {c,s};
    return g;
  } 
  if (selection==15204) {
    camera c = {{0,0,-5},300,300};
    object *pst = poster_obj(xyz_expr(-1,1,3),2,1,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*pst);
    free(pst);
    stage g = {c,s};
    return g;
  } 
  if (selection==15205) {
    camera c = {{0,0,-5},300,300};
    object *pst = poster_obj(xyz_expr(-1,1,3),1,2,&sc_blue,color_expr(0,0,0));
    scene s = {{0,0,0},NULL};
    s.objects = ol_singleton(*pst);
    free(pst);
    stage g = {c,s};
    return g;
  } 
  if (selection==15206) {
    camera c = {{0,0,-5},200,400};
    object *sph0 = sphere_obj(xyz_expr(-1,0,3),0.3,&sc_blue,color_expr(0,0,0));
    object *sph1 = sphere_obj(xyz_expr(1,0,3),0.3,&sc_maroon,color_expr(0,0,0));    
    scene s = {{0,0,0},NULL};
    s.objects = ol_cons(*sph0,ol_singleton(*sph1));
    free(sph0);
    free(sph1);
    stage g = {c,s};
    return g;
  } 

  fprintf(stderr,"error (get_stage): undefined selection %u\n"
                 "(see get_stage in stage.c for available selections)\n",selection);
  exit(1);
}
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project B - texture.c
 */

#include <stdlib.h>
#include <stdio.h>
#include "raytracer.h"
#include <math.h>
#include <unistd.h>

#define PI 3.14159265358979323846


color map_texture_on_sphere(object *o, location intersection)
{
	double alt = o->o.s.center.y - o->o.s.radius;
	double y = intersection.y - alt;
	double pixh = (y/(o->o.s.radius*2))*o->t->height;
	y = (o->o.s.center.y) - intersection.y;
	xyz added = xyz_add(o->o.s.center,xyz_expr(0,y,0));
	xyz polar = xyz_sub(intersection, added);
	double theta = atan(polar.x/polar.z);
	double pixw = ((theta+PI)/(2*PI))*o->t->width;
	int pixel_width = (int)(pixw);
	int pixel_height = (int)(pixh);
	return o->t->pixels[pixel_width][pixel_height];
	
}

color map_texture_on_poster(object *o, location intersection)
{
	double x = intersection.x - o->o.p.upper_left.x;
	double y = o->o.p.upper_left.y - intersection.y;
	double pixel_width = (x/o->o.p.w)*o->t->width;
	double pixel_height = (y/o->o.p.h)*o->t->height;
	int pixw = (int) (pixel_width);
	int pixh = (int) (pixel_height);
	return o->t->pixels[pixw][pixh];
	
}


int findside(cube c, location intersection)
{
		double length = c.length;
		xyz ftl = c.front_top_left;
		
		if(ftl.z - 0.1 <= intersection.z && ftl.z + 0.1 >= intersection.z) {
			return 1; //Face
		}
		if( ftl.x - 0.1 <= intersection.x && ftl.x + 0.1 >= intersection.x) {
			return 2; //Left
		}
		if(ftl.y - 0.1 <= intersection.y && ftl.y + 0.1 >= intersection.y) {
			return 3; //Top
		}
		if(ftl.x + length - 0.1 <= intersection.x && ftl.x + length + 0.1 >= intersection.x) {
			return 4; //Right
		}
		if(ftl.y + length - 0.1 <= intersection.y && ftl.y + length + 0.1 >= intersection.y) {
			return 5; //Bottom
		}
		fprintf(stderr,"error (cube_side): Intersection point is invalid.");
		exit(1);									
}

color map_texture_on_cube_faces(object* o, location intersection)
{
	double x, y, xpix, ypix;
	xyz ftl = o->o.c.front_top_left;
	double length = o->o.c.length;
	int side = findside(o->o.c, intersection);
	switch(side){
		case 1:
		{
			x = fabs(intersection.x - ftl.x);
			y = fabs(ftl.y - intersection.y);
			break;
			
		}
		case 2:
		{
			x = fabs(intersection.z - (ftl.z + length));
			y = fabs(ftl.y - intersection.y);
			break;
		}
		case 3:
		{
			x = fabs(intersection.x - ftl.x);
			y = fabs((ftl.z + length) - intersection.z);
			break;
		}
		case 4:
		{
			x = fabs(intersection.z - ftl.z);
			y = fabs(ftl.y - intersection.y);
			break;
		}
		case 5:
		{
			x = fabs(intersection.x - ftl.x);
			y = fabs(ftl.z - intersection.z);
			break;
		}
		default:
		{
			fprintf(stderr, "error (map_texture_on_cube_faces): Invalid side.");
			exit(1);
		}
	}
	xpix = (x/length)*(o->t->width);
	ypix = (y/length)*(o->t->height);
	return o->t->pixels[(int)xpix][(int)ypix];
}

color map_texture_around_cube(object* o, location intersection)
{
	xyz ftl = o->o.c.front_top_left;
	double x, y, xpix, ypix;
	double length = o->o.c.length;
	int w, h, side;
	int firstw = 0, firsth = 0;
	w = (o->t->width)/3;
	h = (o->t->height)/3;
	side = findside(o->o.c,intersection);
	
	switch (side){
		case 1:
		{
			firstw = w;
			x = fabs(intersection.x - ftl.x);
			y = fabs(ftl.y - intersection.y);
			break;
		}
		
		case 2:
		{
			firsth = h;
			x = fabs(intersection.z - (ftl.z + length));
			y = fabs(ftl.y - intersection.y);
			break;
		}
		
		case 3:
		{
			firstw = w;
			x = fabs(intersection.x - ftl.x);
			y = fabs((ftl.z + length) - intersection.z);
			break;
		}
		
		case 4:
		{
			firstw = 2*w;
			x = fabs(intersection.z - ftl.z);
			y = fabs(ftl.y - intersection.y);
			break;
		}
		
		case 5:
		{
			firstw = w;
			x = fabs(intersection.x - ftl.x);
			y = fabs(ftl.z - intersection.z);
			break;
		}
		default:
		{
			fprintf(stderr, "error (map_texture_around_cube): Invalid side.");
			exit(1);
		}
	}
	
	xpix = firstw + (x/length)*w;
	ypix = firsth + (y/length)*h;
	return o->t->pixels[(int)xpix][(int)ypix];
}


texture *make_horiz_stripes(color c1, color c2, int num_stripes)
{
	texture *bitmap = (texture*)malloc(sizeof(texture));
    if (bitmap==NULL) {
      fprintf(stderr,"error (make_horiz_stripes): malloc failed for bitmap\n");
      exit(1);
    }
	bitmap->pixels = (color **)malloc(sizeof(color *));
	bitmap->pixels[0] = (color *)malloc(sizeof(color) * num_stripes);
	
	
	for (int i = 0; i < num_stripes; i++){
			if (i%2) {
				bitmap->pixels[0][i] = c2;
			} else { 
				bitmap->pixels[0][i] = c1;
			}
	}
	
	bitmap->height = num_stripes;
	bitmap->width = 1;
	
	return bitmap;
}	
texture *make_vert_stripes(color c1, color c2, int num_stripes)
{
	texture *bitmap = (texture *)malloc(sizeof(texture));
   if (bitmap==NULL) {
      fprintf(stderr,"error (make_vert_stripes): malloc failed for bitmap\n");
      exit(1);
    }
	bitmap->pixels = (color **)malloc(sizeof(color *));
	
	
	for (int i = 0; i < num_stripes; i++){
		
	bitmap->pixels[i] = (color *)malloc(sizeof(color));
			if (i%2) {
				bitmap->pixels[i][0] = c2;
			} else {
				bitmap->pixels[i][0] = c1;
			}	
	}
	bitmap->height = 1;
	bitmap->width = num_stripes;
	
	return bitmap;
}	

double dist(double x0, double y0, double x1, double y1){

	double distance = sqrt((x1-x0)*(x1-x0)+(y1-y0)*(y1-y0));
	return distance;

}

texture *make_waves(int length, int x_offset, int y_offset, color col)
{
	texture* waves = (texture *)malloc(sizeof(texture));
		int x, y, distance;
		double b;
		double new_length = (double) (length + 0.5);
		int center = (int) (new_length/2);
		int center_x = center + x_offset;
		int center_y = center + y_offset;
		waves->pixels = (color **)malloc(sizeof(color*)*length);
		for(int i = 0; i<length; i++) {
			waves->pixels[i] = (color *)malloc(sizeof(color)*length);
		}
		for(int j = 0; j<length*length; j++) {
			x = j/length;
			y = j%length;
			distance = dist(center_x,center_y,x,y);
			b = sin(distance)+1;
			waves->pixels[x][y] = color_scale(b,col);
		}
		waves->width = length;
		waves->height = length;
		return waves;
	
	
}	


texture *make_bitmap_from_file(char *filename)
{
	double red, green, blue;
	int r, g, b;
	int h, w, scale;
	
	if (access(filename, F_OK) == -1) {
		fprintf(stderr, "error (make_bitmap_from_file) : file does not exist");
		exit(1);
	}
	
	FILE *f = fopen(filename, "r");
	
	texture *new = (texture *)malloc(sizeof(texture));
	fscanf(f, "%d %d\n", &h, &w);
	fscanf(f, "%d\n", &scale);
	new->height = h;
	new->width = w;
	new->pixels = (color **)malloc(sizeof(color *) * h);
	
	if (f == NULL){
		fprintf(stderr, "error (make_bitmap_from_file) : error opening file");
		exit(1);
	}
	
	for(int i = 0; i < h; i++){
		new->pixels[i] = (color *)malloc(sizeof(color) * w);
		for(int j = 0; j < w; j++){
			fscanf(f, "%d %d %d\n", &r, &g, &b);
			red = ((double)r)/scale;
			green = ((double)g)/scale;
			blue = ((double)b)/scale;
			new->pixels[i][j] = color_expr(red,green,blue);
		}
	}
	
	fclose(f);
	return new;
}
#include <string.h>
#include <math.h>
#include "raytracer.h"

/* ================================== */ 
/* === vector operations => xyz.c === */ 
/* ================================== */ 

xyz xyz_expr(double x, double y, double z)
{
  xyz v = {x,y,z};
  return v;
}

/* xyz_add : add two vectors */
/* (x,y,z) + (X,Y,Z) = (x+X,y+Y,z+Z) */
xyz xyz_add(xyz v1, xyz v2) 
{
  return xyz_expr(v1.x+v2.x,v1.y+v2.y,v1.z+v2.z);
}

/* xyz_sub : subtract the second vector from the first */
/* (x,y,z) - (X,Y,Z) = (x-X,y-Y,z-Z) */
xyz xyz_sub(xyz v1, xyz v2)
{
  return xyz_expr(v1.x-v2.x,v1.y-v2.y,v1.z-v2.z);
}

/* xyz_neg : negate a vector */
/* -(x,y,z) = (-x,-y,-z) */
xyz xyz_neg(xyz v)
{
  return xyz_expr(-v.x,-v.y,-v.z);
}

/* xyz_scale : scale the components of a vector by scalar s */
/* s(x,y,z) = (sx,sy,sz) */
xyz xyz_scale(double s, xyz v)
{
  return xyz_expr(s*v.x,s*v.y,s*v.z);
}

/* xyz_dot : compute the dot product of two vectors */
/* (x,y,z) dot (X,Y,Z) = xX+yY+zZ */
double xyz_dot(xyz v1, xyz v2)
{
  return v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;
}

/* xyz_mag : compute the magnitude of a vector */
/* the square root of the sum of the squares of the components */
double xyz_mag(xyz v)
{
  return sqrt(v.x*v.x+v.y*v.y+v.z*v.z);
}

/* xyz_norm : normalize the vector */
/* i.e., a vector pointing in the same direction whose magnitude is 1 */
/* - normalize a vector by scaling by 1 over its magnitude */
/* - if a vector's magnitude is zero, it can't be normalized; return it */
xyz xyz_norm(xyz v)
{
  double m = xyz_mag(v);
  return m==0 ? v : xyz_scale(1.0/m,v);
}

const char *_xyz_fmt = "xyz(%lf,%lf,%lf)";

char *xyz_tos(xyz v)
{
  char buf[128];
  memset(buf,0,128);
  snprintf(buf,128,_xyz_fmt,v.x,v.y,v.z);
  return strdup(buf);
}

void xyz_show(FILE *f, xyz v)
{
  fprintf(f,_xyz_fmt,v.x,v.y,v.z);
}

#ifndef __RAYTRACER_H__
#define __RAYTRACER_H__

/* raytracer.h
 * CS152 Winter 2015
 * Project C
 * Feb 2015
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>

/* ====================================== */ 
/* ====================================== */ 
/* === STRUCTURE AND TYPE DEFINITIONS === */ 
/* ====================================== */ 
/* ====================================== */ 

typedef unsigned char byte;

typedef struct {
  double x;
  double y;
  double z;
} xyz;

/* Note: Because xyz can be used for both a particular location
 * and a directional vector, we can use the same struct and 
 * typedef for clarity. We may use the three names interchangeably.
 * This allows us to share the basic operations (add, sub, mag, scale).
 * We are not required to use location and direction, it is merely a 
 * tool to help us understand what our (or someone else's) code is doing.
 */

typedef xyz location;
typedef xyz direction;

typedef struct {
  /* each value must be on interval [0,1] */
  double r;
  double g;
  double b;
} color;

typedef struct {
  location origin;
  direction dir;
} ray;

typedef struct _object object;

typedef struct {
  location center;
  double radius;
  color(*surface_color)(object *o, location loc);
  color shine;
  object *o; // optional - you decide whether to use it
} sphere;

typedef struct {
  xyz upper_left;
  double w;
  double h;
  color(*surface_color)(object *poster, location intersection);
  color shine;
  object *o; // optional - you decide whether to use it
} poster;

typedef struct {
 location front_top_left;  // the location of the front, top, left corner 
 double length; // length of every side
 color (*surface_color)(object *o, location intersection);
 color shine;
 object *o;
} cube;

union object_union {
  sphere s;
  poster p;
  cube c;
};

typedef struct {
        color **pixels;
        int height;
        int width;
} texture;

struct _object{
  enum  { SPHERE, POSTER, CUBE } tag;
  union object_union o;
  texture *t;
};

typedef struct obj_list obj_list;
/* convention: NULL is the empty object list */
struct obj_list {
  object obj;
  obj_list *next;
};

typedef struct {
  direction dir; /* note: the vector points AT the light */
  color c;
} light;

typedef struct {
  color bg;
  obj_list *objects;
  light light;
  color amb;
} scene;

typedef struct {
  enum {MISS=0,HIT=1} miss;
  double t;
  location hit_point;
  color surf; 
  color shine; // not used in project B
  direction surf_norm;
} hit_test;

typedef struct {
  location loc;
  unsigned int h;
  unsigned int w;
} camera;

typedef struct {
  camera c;
  scene s;
} stage;

/* ================== */ 
/* ================== */ 
/* === OPERATIONS === */ 
/* ================== */ 
/* ================== */ 

/* Please note: the following is not necessarily every operation you
 * will need, nor will you necessarily use every operation in your
 * implementation.  Add and implement additional operations as you
 * require them.
 */

/* ================================== */ 
/* === vector operations => xyz.c === */ 
/* ================================== */ 

xyz xyz_expr(double x, double y, double z);

/* xyz_add : add two vectors */
/* (x,y,z) + (X,Y,Z) = (x+X,y+Y,z+Z) */
xyz xyz_add(xyz v1, xyz v2);

/* xyz_sub : subtract the second vector from the first */
/* (x,y,z) - (X,Y,Z) = (x-X,y-Y,z-Z) */
xyz xyz_sub(xyz v1, xyz v2);

/* xyz_neg : negate a vector */
/* -(x,y,z) = (-x,-y,-z) */
xyz xyz_neg(xyz v);

/* xyz_scale : scale the components of a vector by scalar s */
/* s(x,y,z) = (sx,sy,sz) */
xyz xyz_scale(double s, xyz v);

/* xyz_dot : compute the dot product of two vectors */
/* (x,y,z) dot (X,Y,Z) = xX+yY+zZ */
double xyz_dot(xyz v1, xyz v2);

/* xyz_mag : compute the magnitude of a vector */
/* the square root of the sum of the squares of the components */
double xyz_mag(xyz v);

/* xyz_norm : normalize the vector */
/* i.e., a vector pointing in the same direction whose magnitude is 1 */
/* - normalize a vector by scaling by 1 over its magnitude */
/* - if a vector's magnitude is zero, it can't be normalized; return it */
xyz xyz_norm(xyz v);

char *xyz_tos(xyz v);

void xyz_show(FILE *f, xyz v);

/* =============================== */ 
/* === color operations => color.c === */ 
/* =============================== */ 

/* reject if any component is outside [0.0,1.0] */
color color_expr(double r, double g, double b);

/* color_modulate : multiply the components or two colors */
/* (r,g,b) * (R,G,B) = (rR,gG,bB) */
color color_modulate(color c1, color c2);

/* color_scale : scale each component by given scalar, but */
/* don't allow any component in the result to fall outside [0,1] */
color color_scale(double s, color c);

/* add components of colors, but */
/* don't allow any component in the result to exceed 1 */
color color_add(color c1, color c2);

char *color_tos(color c);

void color_show(FILE *f, color c);

/* color_show_bytes */
/* print three integers on [0,255] with spaces in between and a newline */
/* suitable for use in a PPM */
void color_show_bytes(FILE *f, color c);

/* ===================================== */ 
/* === cube operations => cube.c === */ 
/* ===================================== */ 

/* cube_expr : construct a cube record,
 * setting object pointer to NULL (unused in this implementation)
 * and texture to NULL (future expansion)
 */
cube cube_expr(location ftl, 
		   double l, 
		   color(*sc)(object *,location), 
		   color sh);
char *cube_tos(cube c);
void cube_show(FILE *f, cube c);	

/* =============================== */ 
/* === ray operations => ray.c === */ 
/* =============================== */ 

/* see web page for ray_position code */
xyz ray_position(ray r, double t);

char *ray_tos(ray r);

void ray_show(FILE *f, ray r);

/* ===================================== */ 
/* === sphere operations => sphere.c === */ 
/* ===================================== */ 

sphere sphere_expr(location v, double r, color(*sc)(object *,location), color sh);

char *sphere_tos(sphere s);

void sphere_show(FILE *f, sphere s);

/* ===================================== */ 
/* === slab operations => poster.c ===== */ 
/* ===================================== */ 

poster poster_expr(location ulc, double w, double h, 
		   color(*sc)(object*,location), color sh);

char *poster_tos(poster s);

void poster_show(FILE *f, poster s);

/* ===================================== */ 
/* === object operations => object.c === */ 
/* ===================================== */ 

char *object_tos(object o);

void object_show(FILE *f, object o);

/* ======================================== */ 
/* === object list ops => obj_list.c ====== */ 
/* ======================================== */ 

obj_list *ol_cons(object o, obj_list *os);

obj_list *ol_singleton(object s);

char *ol_tos(obj_list *os);

void ol_show(FILE *f, obj_list *os);

void ol_free(obj_list *ss);

/* =================================== */ 
/* === light operations => light.c === */ 
/* =================================== */ 

char *light_tos(light l);

void light_show(FILE *f, light l);

/* =================================== */ 
/* === scene operations => scene.c === */ 
/* =================================== */ 

char *scene_tos(scene sc);

void scene_show(FILE *f, scene sc);

/* ========================================= */ 
/* === hit_test operations => hit_test.c === */ 
/* ========================================= */ 

char *hit_test_tos(hit_test t);

void hit_test_show(FILE *f, hit_test t);

/* ===================================== */ 
/* === camera operations => camera.c === */ 
/* ===================================== */ 

char *camera_tos(camera cm);

void camera_show(FILE *f, camera cm);

/* =================================== */ 
/* === stage operations => stage.c === */ 
/* =================================== */ 

char *stage_tos(stage stg);

void stage_show(FILE *f, stage stg);

/* The function get_stage just needs to return a valid stage. */
/* The argument may be used, or not, at your discretion. */
stage get_stage(unsigned int selection);

/* ================================================ */ 
/* ================================================ */ 
/* === RAY TRACER LOGIC and MAIN => raytracer.c === */ 
/* ================================================ */ 
/* ================================================ */ 

/* === project 1 operations === */

/* === intersect.c === */

hit_test intersect(ray r, object obj);

/* === raytracer.c === */

/* Functions from project A */
location logical_loc(camera c, unsigned int x, unsigned int y);
color trace_ray(scene s, ray r);
void render(FILE *f, stage g);

/* Functions from project B */

/* Given an intersection location p, light source, and object list,
 * check each object to see if it intersects the shadow ray. 
 * return nonzero if the location p is in shadow. Return 0 if not.
 */
int shadow(location p, light l, obj_list *objs);

/* Given a scene, ray, and hit_test, determine the color of the pixel.
 * The hit_test already calculated the surface color of the shape in the 
 * absence of lighting. Here, you take into account shadow and ambient
 * light to adjust the color. */
color lighting(scene s, ray r, hit_test h);

/* === rt.c === */

int main(int argc, char *argv[]);

/* === texture.c === */
/* Functions from project A that you already implemented */

/* poster_red_distance - calculate distance from upper-left-corner, use to 
 * scale from black at upper-left to red at lower-right
 */
color poster_red_distance(object *o, location loc); 
/* poster_rgb_distance: calculate distance from upper-left-corner, use to 
 * scale from all red at upper-left to all blue at lower-right, with 
 * green in the middle, and gradations between them.
 */
color poster_rgb_distance(object *o, location loc); 
/* sphere_loc_to_rgb: scale the location so that it maps x, y, z onto r, g, b 
 * in a way that shows gradations in the sphere. 
 */
color sphere_loc_to_rgb(object *o, location loc); 
/* sphere_stripes: color the sphere with 4 blue stripes on a white background.*/
color sphere_horiz_stripes(object *o, location loc); 

/* Functions in project B that you are supposed to implement  - see
 * assignment description for details on each function. */
color map_texture_on_poster(object *o, location intersection);
color map_texture_on_sphere(object *o, location intersection);
texture *make_horiz_stripes(color c1, color c2, int num_stripes);
texture *make_vert_stripes(color c1, color c2, int num_stripes);
texture *make_waves(int length, int x_offset, int y_offset, color col);

/* make_bitmap_from_file
 * This function a) opens the file, b) reads the information
 * in the file to allocate and populate the texture map,
 * c) closes the file, d) returns the resulting texture
 * If the file does not exist, print an error and exit.
 */
texture *make_bitmap_from_file(char *filename);

/* map_texture_on_cube_faces takes an object (which must have
 * tag == CUBE) and an intersection point. It uses the bitmap contained
 * in the object, the attributes of the cube, and the intersection
 * point to determine the color at that intersection point.
 * The same 2D bitmap will display on each face of the cube.
 */
color map_texture_on_cube_faces(object *o, location intersection);

/* map_texture_around_cube takes an object (which must have
 * tag == CUBE) and an intersection point. It uses the bitmap contained
 * in the object, the attributes of the cube, and the intersection
 * point to determine the color at that intersection point.
 * For the cube, because the back is not visible, ignore it. Instead, 
 * flatten the cube into a "+" sign and map that "+" sign onto the 
 * 2D bitmap. This means that the corners of the 2-d bitmap will not
 * get mapped anywhere onto the cube.
 */
color map_texture_around_cube(object *o, location intersection);

#endif /* __RAYTRACER_H__ */


# Makefile (starter)
# CS152 Winter 2016
# Project C

.PHONY: clean

SRC = xyz.c color.c ray.c sphere.c poster.c object.c obj_list.c scene.c light.c camera.c hit_test.c stage.c intersect.c raytracer.c rt.c texture.c cube.c

trace: raytracer.h $(SRC)
	clang -g -O3 -Wall -o rt $(SRC) -lm

clean:
	rm -rf rt *.dSYM *.ppm
