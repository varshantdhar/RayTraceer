
;; _total-score_                    40 / 100

;; ====== correctness

;; The reason for visual inspection is so that
;; not everything needs to be exact. Please give
;; partial credit when appropriate, and don't require
;; everything to look *exactly* like the reference
;; picture.

;; === Single posters ===
;; Single blue poster			/ 5
;; Single RGB Gradient Poster		/ 5
;; Single Red Gradient Poster		/ 5

;; === Camera angles ===
;; Tall poster (ignore color)		/ 5
;; High resolution poster (ignore color) / 5
;; shift camera (ignore color)		/ 5
;; poster far away (ignore color)	/ 5

;; === Single spheres ===
;; Single blue sphere			/ 5
;; Stripes				/ 5
;; Colored sphere (does not need to be exact) / 5

;; === Multiple objects ===
;; Overlapping spheres (ignore color)	/ 5
;; Two posters				/ 5
;; Hidden poster			/ 5
;; Poster behind spheres (ignore color) / 5

;; _correctness_subtotal		0/ 70

;; === style ===

;; development process		    14 / 15 (runtime segfault)
-4 - compiled properly with their own files
-4 - functions are complete and in the appropriate files
-4 - used subversion correctly		
-15 - required editing their code (to do more than problems above)
(take off no more than 10)

;; adequate tests                    3/ 5
(no helper function tests necessary)
(tests should be modularized)

;; well-written purposes             2/ 2
;; proper indentation, line breaks   2/ 2
;; well-named variables		     2/ 2

;; === efficiency ===
;; make sure to grade their test code for efficiency, as well
;; well-chosen control structures    4/ 4
(no blatant inefficiencies or confusing control)

;; _style_subtotal		27 / 30

;; === partial credit ===
;; They only earn points here for places where
;;  they earned 0 for correctness tests

;; If none of their pictures showed, inspect for
;; a very good attempt at these:
;; location_loc reasonably complete 2/ 2
;; checking tags properly	2/ 2
;; double for loop for each pixel, 2/ 2
;; call location_loc 		2/ 2
;; intersect poster		2/ 2
;; intersect sphere		2/ 2
;; call to surface_color	1/ 1

;; If some worked but texture maps didn't:
;; (if nothing worked, they cannot get these points)
;; poster_red_distance			/ 2
;; poster_rgb_distance			/ 2
;; sphere_loc_to_rgb			/ 2
;; sphere_horiz_stripes			/ 2

;; partial_credit _subtotal_:	 	13
;; note to students: this is only available to
;; for portions that did not pass correctness testing


;; graded by Liwen Zhang

======== camera.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - camera.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

char *camera_tos(camera cm){
	
	char *string;
	char temp[100];
	sprintf(temp, "Location: {%lf, %lf, %lf}\n Height: %d\n Width: %d\n",
	cm.loc.x, cm.loc.y, cm.loc.y, cm.h, cm.w);
	string = strdup(temp);
	return string;
	free(string);
}

void camera_show(FILE *f, camera cm){
	
	fprintf(f, "Location: {%lf, %lf, %lf}\n Height: %d\n Width: %d\n",
	cm.loc.x, cm.loc.y, cm.loc.y, cm.h, cm.w);
} 
 
======== color.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - color.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

color color_expr(double r, double g, double b){
	
	if(r >= 0 && r <= 1 && g >= 0 && g <= 1 && b >= 0 && b <= 1){
		color color_new;
		color_new.r = r;
		color_new.g = g;
		color_new.b = b;
		return color_new;
		//free(color_new);
	} else {
		fprintf(stderr, "error(color_new): not within range");
		exit(1);
	}
}

color color_modulate(color c1, color c2){
	
	color color_modulate;
	color_modulate.r = c1.r*c2.r;
	color_modulate.g = c1.g*c2.g;
	color_modulate.b = c1.b*c2.b;
	return color_modulate;
	//free(color_modulate);
}

color color_scale(double s, color c){
	
	color color_scale;
	if (s*c.r >= 0 && s*c.r <= 1)
		color_scale.r = s*c.r;
	else {
		fprintf(stderr, "error(color_scale): r not within range");
		exit(1);
	} 
	
	if (s*c.g >= 0 && s*c.g <= 1)
		color_scale.g = s*c.g;
	else {
		fprintf(stderr, "error(color_scale): g not within range");
		exit(1);
	}
	
	if (s*c.b >= 0 && s*c.b <= 1)
		color_scale.b = s*c.b;
	else {
		fprintf(stderr, "error(color_scale): b not within range");
		exit(1);
	}
	
	return color_scale;
	//free(color_scale);
}

color color_add(color c1, color c2){
	
	color color_add;
	if(c1.r+c2.r <= 1 && c1.r+c2.r >= 0)
		color_add.r = c1.r+c2.r;
	else {
		fprintf(stderr, "error(color_add): r not within range");
		exit(1);
	}
	
	if(c1.g+c2.g <= 1 && c1.g+c2.g >= 0)
		color_add.g = c1.g+c2.g;
	else {
		fprintf(stderr, "error(color_add): g not within range");
		exit(1);
	}
	
	if(c1.b+c2.b <= 1 && c1.b+c2.b >= 0)
		color_add.b = c1.b+c2.b;
	else {
		fprintf(stderr, "error(color_add): b not within range");
		exit(1);
	}
	
	return color_add;
	//free(color_add);
}

char *color_tos(color c){
	
	char *string;
	char temp[100];
	sprintf(temp, "{%lf, %lf, %lf}", c.r, c.g, c.b);
	string = strdup(temp);
	return string;
	//free(string);
}

void color_show(FILE *f, color c){
	
	fprintf(f, "{%lf, %lf, %lf}", c.r, c.g, c.b);
}

void color_show_bytes(FILE *f, color c){
	
	int r = (int)(c.r*255);
	int g = (int)(c.g*255);
	int b = (int)(c.b*255);
	fprintf(f, "%d %d %d\n", r, g, b);
} 
 
======== hit_test.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - hit_test.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

char *hit_test_tos(hit_test t){
	
	char *string;
	char temp[100];
	if(t.miss == MISS)
		sprintf(temp, "MISS\n%lf Hit-Point: {%lf, %lf, %lf}", t.t, t.hit_point.x, t.hit_point.y, t.hit_point.z);
	else
		sprintf(temp, "HIT\n%lf Hit-Point: {%lf, %lf, %lf}", t.t, t.hit_point.x, t.hit_point.y, t.hit_point.z);
	string = strdup(temp);
	return string;
	free(string);	
}

void hit_test_show(FILE *f, hit_test t){
	
	if(t.miss == MISS)
		fprintf(f, "MISS\n%lf Hit-Point: {%lf, %lf, %lf}", t.t, t.hit_point.x, t.hit_point.y, t.hit_point.z);
	else
		fprintf(f, "HIT\n%lf Hit-Point: {%lf, %lf, %lf}", t.t, t.hit_point.x, t.hit_point.y, t.hit_point.z);
	
} 
 
======== intersect.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - intersect.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

/* typedef struct {
  location origin;
  direction dir;
} ray;

struct _object{
  enum  { SPHERE, POSTER } tag;
  union object_union o;
  texture *t; // NULL in project A
};

union object_union {
  sphere s;
  poster p;
};

typedef struct {
  location center;
  double radius;
  color(*surface_color)(object *o, location loc);
  color shine; // not used in project A
  object *o;
} sphere;

typedef struct {
  xyz upper_left;
  double w;
  double h;
  color(*surface_color)(object *poster, location intersection);
  color shine; // not used in project A
  object *o;
} poster;

typedef struct {
  enum {MISS=0,HIT=1} miss;
  double t;
  location hit_point;
  color surf;
  color shine; // not used in project A
  direction surf_norm; // not used in project A
} hit_test;
*/

hit_test intersect(ray r, object obj){
	
	location ro, sc, a;
	double sr, b, c, d, t;
	direction rd, n;
	if (obj.tag == SPHERE){
		sc.x = obj.o.s.center.x;
		sc.y = obj.o.s.center.y;
		sc.z = obj.o.s.center.z;
		rd.x = r.dir.x;
		rd.y = r.dir.y;
		rd.z = r.dir.z;
		ro.x = r.origin.x;
		ro.y = r.origin.y;
		ro.z = r.origin.z;
		sr = obj.o.s.radius;
		a = xyz_sub(ro, sc);
		b = xyz_dot(a, rd);
		c = xyz_dot(a, a) - (sr*sr);
		d = (b*b) - c;
		t = (-1.0 * b) - sqrt(d);
		if(d>0 && t>0){
			hit_test hit;
			hit.miss = HIT;
			hit.t = t;
			hit.hit_point = xyz_add(ro, xyz_scale(t,rd));
			hit.surf = obj.o.s.surface_color(obj.o.s.o, hit.hit_point);
			return hit;
			//free(hit);
		}
		else {
			hit_test hit;
			hit.miss = MISS;
			return hit;
			//free(hit);
		}
	}
	
	else {
		ro.x = r.origin.x;
		ro.y = r.origin.y;
		ro.z = r.origin.z;
		rd.x = r.dir.x;
		rd.y = r.dir.y;
		rd.z = r.dir.z;
		n.x = 0;
		n.y = 0;
		n.z = -1;
		d = obj.o.p.upper_left.z;
		t = -((xyz_dot(ro, n)) + d) / (xyz_dot(rd, n));
		if(t>0) {
			hit_test hit;
			hit.miss = HIT;
			hit.t = t;
			hit.hit_point = xyz_add(ro, xyz_scale(t,rd));
			hit.surf = obj.o.p.surface_color(obj.o.p.o, hit.hit_point);
			return hit;
			//free(hit);
		} 
		else {
			hit_test hit;
			hit.miss = MISS;
			return hit;
			//free(hit);
		}
	} 
} 
 
======== light.c ========
 
 
======== Makefile ========
# Makefile (starter)
# CS152 Winter 2016
# Project A

.PHONY: clean

SRC = xyz.c color.c ray.c sphere.c poster.c object.c obj_list.c scene.c light.c camera.c hit_test.c stage.c intersect.c raytracer.c rt.c 

trace: raytracer.h $(SRC)
	clang -g -O3 -Wall -o rt $(SRC) -lm

clean:
	rm -rf rt *.dSYM *.ppm
 
 
======== object.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - object.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

char *object_tos(object o){
	
	char *string;
	char temp[100];
	if(o.tag == SPHERE)
		sprintf(temp, "SPHERE");
	else
		sprintf(temp, "POSTER");
	string = strdup(temp);
	return string;
	free(string);
}

void object_show(FILE *f, object o){
	
	if(o.tag == SPHERE)
		fprintf(f, "SPHERE");
	else
		fprintf(f, "POSTER");
	
} 
 
======== obj_list.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - obj_list.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

obj_list *ol_cons(object o, obj_list *os){
	
	struct obj_list *obj_con = malloc(sizeof(struct obj_list));
	obj_con->obj = o;
	obj_con->next = os;
	return obj_con;
	free(obj_con);
}

obj_list *ol_singleton(object s){
	
	struct obj_list *obj_single = malloc(sizeof(struct obj_list));
	obj_single->obj = s;
	obj_single->next = NULL;
	return obj_single;
	free(obj_single);
}

char *ol_tos(obj_list *os){
	
	char *string;
	char temp[500];
	struct obj_list *tmp;
	sprintf(temp, "{");
	for (tmp = os; tmp != NULL; tmp = tmp->next){
		if (tmp->obj.tag == SPHERE)
			sprintf(temp, "SPHERE, ");
		else
			sprintf(temp, "POSTER, ");
	}
	sprintf(temp, "}");
	string = strdup(temp);
	return string;
	free(string);
}

void ol_show(FILE *f, obj_list *os){
	
	struct obj_list *tmp;
	fprintf(f, "{");
	for (tmp = os; tmp != NULL; tmp = tmp->next){
		if (tmp->obj.tag == SPHERE)
			fprintf(f, "SPHERE, ");
		else
			fprintf(f, "POSTER, ");
	}
	fprintf(f, "}");
	
}

void ol_free(obj_list *ss){
	
	struct obj_list *tmp;
	while((tmp = ss) != NULL){
		ss = ss->next;
		free(tmp);
	}
} 
 
======== poster.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - poster.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

poster poster_expr(location ulc, double w, double h, color(*sc)(object*,location), color sh){
	
	poster new_poster;
	new_poster.upper_left.x = ulc.x;
	new_poster.upper_left.y = ulc.y;
	new_poster.upper_left.z = ulc.z;
	new_poster.w = w;
	new_poster.h = h;
	new_poster.surface_color = sc;
	new_poster.shine.r = sh.r;
	new_poster.shine.g = sh.g;
	new_poster.shine.b = sh.b;
	return new_poster;
	//free(new_poster);
}

char *poster_tos(poster s){
	
	char *string;
	char temp[100];
	sprintf(temp, "Upper Left: {%lf, %lf, %lf}\nWidth: %lf\nHeight: %lf\nShine: {%lf, %lf, %lf}", 
	s.upper_left.x, s.upper_left.y, s.upper_left.z, s.w, s.h, s.shine.r, s.shine.g, s.shine.b);
	string = strdup(temp);
	return string;
	free(string);
}

void poster_show(FILE *f, poster s){
	
	fprintf(f, "Upper Left: {%lf, %lf, %lf}\nWidth: %lf\nHeight: %lf\nShine: {%lf, %lf, %lf}", 
	s.upper_left.x, s.upper_left.y, s.upper_left.z, s.w, s.h, s.shine.r, s.shine.g, s.shine.b);
} 
 
======== ray.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - ray.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

/* ray_position: interpreting direction as velocity, calculate position
 * of ray r after time t. 
 */
xyz ray_position(ray r, double t)
{
  return xyz_add(r.origin, xyz_scale(t, r.dir));
}

char *ray_tos(ray r){
	
	char *string;
	char temp[100];
	sprintf(temp, "Origin: {%lf, %lf, %lf}; Direction: {%lf, %lf, %lf}", 
	r.origin.x, r.origin.y, r.origin.z, r.dir.x, r.dir.y, r.dir.z);
	string = strdup(temp);
	return string;
	free(string);
}

void ray_show(FILE *f, ray r){
	
	fprintf(f, "Origin: {%lf, %lf, %lf}; Direction: {%lf, %lf, %lf}", 
	r.origin.x, r.origin.y, r.origin.z, r.dir.x, r.dir.y, r.dir.z);
} 
 
======== raytracer.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - raytracer.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"


location logical_loc(camera c, unsigned int x, unsigned int y){
	
	double h, w, x_calc, y_calc;
	h = c.h;
	w = c.w;
	if (h > w){
		x_calc = -1.0 + ((h-2)/h) + (1.0/h) + ((2*x)/h);
		y_calc = 1.0 - (1.0/h) - ((2*y)/h);
	} 
	else {
		x_calc = -1.0 + (1.0/w) + ((2*x)/w);
		y_calc = 1.0 - ((w-h)/w) - (1/w) - ((2*y)/w);
	}
	
	location logic = xyz_expr(x_calc, y_calc, 0);
	return logic;
	
}

color returns_color (object o, location loc){
	
	object *op = &o;
	if (o.tag == SPHERE)
	    return o.o.s.surface_color(op, loc);
	else 
	    return o.o.p.surface_color(op,loc);
}

color trace_ray(scene s, ray r){
	
	color new_c = s.bg;
	double t = 19102020102.00;
	obj_list* tmp;
	for(tmp = s.objects; tmp != NULL; tmp = tmp->next){
		hit_test hit1 = intersect(r, tmp->obj);
		if(hit1.miss == HIT && hit1.t<=t){
			new_c = returns_color(tmp->obj, hit1.hit_point);
			t = hit1.t;
		} 
	}
	return new_c;
}	


void render(FILE *f, stage g){
	
	double w, h;
	unsigned int red, green, blue;
	location loc;
	color rcolor;
	ray new_ray;
	w = g.c.w;
	h = g.c.h;
	fprintf(f,"P3\n%d %d\n255\n", (int) (w), (int) (h));
	for(int i = 0; i<w; i++){
		for(int j = 0; j<h; j++){
			loc = logical_loc(g.c, i, j);
			new_ray.origin = g.c.loc;
			new_ray.dir = xyz_norm(loc);
			rcolor = trace_ray(g.s, new_ray);
			red = (int) (rcolor.r * 255);
			green = (int) (rcolor.g * 255);
			blue = (int) (rcolor.b * 255);
			fprintf(f, "%d %d %d\n", red, green, blue);
		}
	}	
} 
 
======== raytracer.h ========
#ifndef __RAYTRACER_H__
#define __RAYTRACER_H__

/* raytracer.h
 * CS152 Winter 2016
 * Project A
 * Feb 2015
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>

/* ====================================== */ 
/* ====================================== */ 
/* === STRUCTURE AND TYPE DEFINITIONS === */ 
/* ====================================== */ 
/* ====================================== */ 

typedef unsigned char byte;

typedef struct {
  double x;
  double y;
  double z;
} xyz;

/* Note: Because xyz can be used for both a particular location
 * and a directional vector, we can use the same struct and 
 * typedef for clarity. We may use the three names interchangeably.
 * This allows us to share the basic operations (add, sub, mag, scale).
 * We are not required to use location and direction, it is merely a 
 * tool to help us understand what our (or someone else's) code is doing.
 */

typedef xyz location;
typedef xyz direction;

typedef struct {
  /* each value must be on interval [0,1] */
  double r;
  double g;
  double b;
} color;

typedef struct {
  location origin;
  direction dir;
} ray;

typedef struct _object object;

typedef struct {
  location center;
  double radius;
  color(*surface_color)(object *o, location loc);
  color shine; // not used in project A
  object *o;
} sphere;

typedef struct {
  xyz upper_left;
  double w;
  double h;
  color(*surface_color)(object *poster, location intersection);
  color shine; // not used in project A
  object *o;
} poster;

union object_union {
  sphere s;
  poster p;
};

/* texture used in project B */
typedef struct {
        color **pixels;
        int height;
        int width;
} texture;

struct _object{
  enum  { SPHERE, POSTER } tag;
  union object_union o;
  texture *t; // NULL in project A
};

typedef struct obj_list obj_list;
/* convention: NULL is the empty object list */
struct obj_list {
  object obj;
  obj_list *next;
};

/* not used in project A */
typedef struct {
  direction dir; /* note: the vector points AT the light */
  color c;
} light;

typedef struct {
  color bg;
  obj_list *objects;
  light light; // not used in project A
  color amb; // not used in project A
} scene;

typedef struct {
  enum {MISS=0,HIT=1} miss;
  double t;
  location hit_point;
  color surf; // not used in project A
  color shine; // not used in project A
  direction surf_norm; // not used in project A
} hit_test;

typedef struct {
  location loc;
  unsigned int h;
  unsigned int w;
} camera;

typedef struct {
  camera c;
  scene s;
} stage;

/* ================== */ 
/* ================== */ 
/* === OPERATIONS === */ 
/* ================== */ 
/* ================== */ 

/* Please note: the following is not necessarily every operation you
 * will need, nor will you necessarily use every operation in your
 * implementation.  Add and implement additional operations as you
 * require them.
 */

/* ================================== */ 
/* === vector operations => xyz.c === */ 
/* ================================== */ 

xyz xyz_expr(double x, double y, double z);

/* xyz_add : add two vectors */
/* (x,y,z) + (X,Y,Z) = (x+X,y+Y,z+Z) */
xyz xyz_add(xyz v1, xyz v2);

/* xyz_sub : subtract the second vector from the first */
/* (x,y,z) - (X,Y,Z) = (x-X,y-Y,z-Z) */
xyz xyz_sub(xyz v1, xyz v2);

/* xyz_neg : negate a vector */
/* -(x,y,z) = (-x,-y,-z) */
xyz xyz_neg(xyz v);

/* xyz_scale : scale the components of a vector by scalar s */
/* s(x,y,z) = (sx,sy,sz) */
xyz xyz_scale(double s, xyz v);

/* xyz_dot : compute the dot product of two vectors */
/* (x,y,z) dot (X,Y,Z) = xX+yY+zZ */
double xyz_dot(xyz v1, xyz v2);

/* xyz_mag : compute the magnitude of a vector */
/* the square root of the sum of the squares of the components */
double xyz_mag(xyz v);

/* xyz_norm : normalize the vector */
/* i.e., a vector pointing in the same direction whose magnitude is 1 */
/* - normalize a vector by scaling by 1 over its magnitude */
/* - if a vector's magnitude is zero, it can't be normalized; return it */
xyz xyz_norm(xyz v);

char *xyz_tos(xyz v);

void xyz_show(FILE *f, xyz v);

/* =================================== */ 
/* === color operations => color.c === */ 
/* =================================== */ 

/* reject if any component is outside [0.0,1.0] */
color color_expr(double r, double g, double b);

/* color_modulate : multiply the components or two colors */
/* (r,g,b) * (R,G,B) = (rR,gG,bB) */
color color_modulate(color c1, color c2);

/* color_scale : scale each component by given scalar, but */
/* don't allow any component in the result to fall outside [0,1] */
color color_scale(double s, color c);

/* add components of colors, but */
/* don't allow any component in the result to exceed 1 */
color color_add(color c1, color c2);

char *color_tos(color c);

void color_show(FILE *f, color c);

/* color_show_bytes */
/* print three integers on [0,255] with spaces in between and a newline */
/* suitable for use in a PPM */
void color_show_bytes(FILE *f, color c);

/* =============================== */ 
/* === ray operations => ray.c === */ 
/* =============================== */ 

/* see web page for ray_position code */
xyz ray_position(ray r, double t);

char *ray_tos(ray r);

void ray_show(FILE *f, ray r);

/* ===================================== */ 
/* === sphere operations => sphere.c === */ 
/* ===================================== */ 

sphere sphere_expr(location v, double r, color(*sc)(object *,location), color sh);

char *sphere_tos(sphere s);

void sphere_show(FILE *f, sphere s);

/* ===================================== */ 
/* === slab operations => poster.c ===== */ 
/* ===================================== */ 

poster poster_expr(location ulc, double w, double h, color(*sc)(object*,location), color sh);

char *poster_tos(poster s);

void poster_show(FILE *f, poster s);

/* ===================================== */ 
/* === object operations => object.c === */ 
/* ===================================== */ 

char *object_tos(object o);

void object_show(FILE *f, object o);

/* ======================================== */ 
/* === object list ops => obj_list.c === */ 
/* ======================================== */ 

obj_list *ol_cons(object o, obj_list *os);

obj_list *ol_singleton(object s);

char *ol_tos(obj_list *os);

void ol_show(FILE *f, obj_list *os);

void ol_free(obj_list *ss);

/* =================================== */ 
/* === scene operations => scene.c === */ 
/* =================================== */ 

char *scene_tos(scene sc);

void scene_show(FILE *f, scene sc);

/* ========================================= */ 
/* === hit_test operations => hit_test.c === */ 
/* ========================================= */ 

char *hit_test_tos(hit_test t);

void hit_test_show(FILE *f, hit_test t);

/* ===================================== */ 
/* === camera operations => camera.c === */ 
/* ===================================== */ 

char *camera_tos(camera cm);

void camera_show(FILE *f, camera cm);

/* =================================== */ 
/* === stage operations => stage.c === */ 
/* =================================== */ 

char *stage_tos(stage stg);

void stage_show(FILE *f, stage stg);

/* The function get_stage just needs to return a valid stage. */
/* The argument may be used, or not, at your discretion. */
stage get_stage(unsigned int selection);

/* ================================================ */ 
/* ================================================ */ 
/* === RAY TRACER LOGIC and MAIN => raytracer.c === */ 
/* ================================================ */ 
/* ================================================ */ 

/* === project 1 operations === */

/* === intersect.c === */

hit_test intersect(ray r, object obj);

/* === raytracer.c === */

location logical_loc(camera c, unsigned int x, unsigned int y);

color trace_ray(scene s, ray r);

void render(FILE *f, stage g);

/* === texture.c === */

/* poster_red_distance - calculate distance from upper-left-corner, use to 
 * scale from black at upper-left to red at lower-right
 */
color poster_red_distance(object *o, location loc); 
/* poster_rgb_distance - calculate distance from upper-left-corner, use to 
 * scale from all red at upper-left to all blue at lower-right, with 
 * green in the middle, and gradations between them.
 */
/* ^^ edit: said "blue at lower-left", corrected to "at lower-right" */
color poster_rgb_distance(object *o, location loc); 
/* sphere_loc_to_rgb - scale the location so that it maps x, y, z onto r, g, b in 
 * a way that shows gradations in the sphere. You are being given flexibility to 
 * do this in a way that looks interesting to you.
 */
color sphere_loc_to_rgb(object *o, location loc); 
/* sphere_stripes - color the sphere with 4 blue stripes on a white background.
 * the pattern is: WBWBWBWBW. The stripes and background are roughly equal height.
 */
color sphere_horiz_stripes(object *o, location loc);

/* === rt.c === */

int main(int argc, char *argv[]);

#endif /* __RAYTRACER_H__ */

 
 
======== rt.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - rt.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

color poster_red_distance(object *o, location loc){
	
	double max_dist, dist, ulc_x, ulc_y, squared_x, squared_y, w, h;
	ulc_x = o->o.p.upper_left.x;
	ulc_y = o->o.p.upper_left.y;
	squared_x = (loc.x - ulc_x)*(loc.x - ulc_x);
	squared_y = (loc.y - ulc_y)*(loc.y - ulc_y);
	dist = sqrt(squared_x + squared_y);
	w = o->o.p.w;
	h = o->o.p.h;
	max_dist = sqrt(w*w+h*h);
	color new_color;
	new_color.r = dist/max_dist;
	new_color.g = 0;
	new_color.b = 0;
	return new_color;
	
	
}

color poster_rgb_distance(object *o, location loc){
	
	double max_dist, dist, ulc_x, ulc_y, squared_x, squared_y, w, h;
	ulc_x = o->o.p.upper_left.x;
	ulc_y = o->o.p.upper_left.y;
	squared_x = (loc.x - ulc_x)*(loc.x - ulc_x);
	squared_y = (loc.y - ulc_y)*(loc.y - ulc_y);
	dist = sqrt(squared_x + squared_y);
	w = o->o.p.w;
	h = o->o.p.h;
	max_dist = sqrt(w*w+h*h);
	color new_color;
	new_color.r = ((dist) < (max_dist/2) ? ((-2.0 / max_dist) * dist + 1) : 0.0);
	new_color.g = ((dist) < (max_dist/2) ? ((2/max_dist) * dist) : ((-2.0/max_dist) * dist + 2.0));
	new_color.b = ((dist) < (max_dist/2) ? 0.0 : ((2.0/max_dist) * dist - 1));
	return new_color;
	
}

color sphere_loc_to_rgb(object *o, location loc){
	
		double rad, x, y, z;
		rad = o->o.s.radius;
		x = o->o.s.center.x;
		y = o->o.s.center.y;
		z = o->o.s.center.z;
		color new_color;
		new_color.r = (1/rad)*(loc.x + rad - x);
		new_color.g = (1/rad)*(loc.y + rad - y);
		new_color.b = (1/rad)*(loc.z + rad - z);
		return new_color;
				
}

color sphere_horiz_stripes(object *o, location loc){
	
		double rad, y;
		color new_color;
		rad = o->o.s.radius;
		y = o->o.s.center.y;
		if ((loc.y >= y + (1/9) * rad && loc.y <= y + (3/9) * rad) ||
			(loc.y >= y + (5/9) * rad && loc.y <= y + (7/9) * rad) ||
			(loc.y >= y - (5/9) * rad && loc.y <= y - (7/9) * rad) ||
			(loc.y >= y - (3/9) * rad && loc.y <= y - (1/9) * rad)) {
				new_color.r = 0.0;
				new_color.g = 0.0;
				new_color.b = 1.0;
				return new_color;
			} else {
				new_color.r = 1.0;
				new_color.g = 1.0;
				new_color.b = 1.0;
				return new_color;
			}	
}



int main(int argc, char *argv[]){
	
	render(stdout, get_stage(1));
	return 0;
}
 
 
======== scene.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - scene.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

char *scene_tos(scene sc){
	
	char *string;
	char temp[500];
	sprintf(temp, "BG Color: {%lf, %lf, %lf}\n", sc.bg.r, sc.bg.g, sc.bg.b);
	struct obj_list *tmp;
	sprintf(temp,"Objects: {");
	for (tmp = sc.objects; tmp != NULL; tmp = tmp->next){
		if (tmp->obj.tag == SPHERE)
			sprintf(temp, "SPHERE, ");
		else
			sprintf(temp, "POSTER, ");
	}
	sprintf(temp,"}\n");
	string = strdup(temp);
	return string;
	free(string);
}

void scene_show(FILE *f, scene sc){
	
	fprintf(f, "%s", scene_tos(sc));
	
} 
 
======== sphere.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - sphere.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

sphere sphere_expr(location v, double r, color(*sc)(object *,location), color sh){
	
	sphere new_sphere;
	new_sphere.center = v;
	new_sphere.radius = r;
	new_sphere.surface_color = sc;
	new_sphere.shine.r = sh.r;
	new_sphere.shine.g = sh.g;
	new_sphere.shine.b = sh.b;
	return new_sphere;
	//free(new_sphere);
}

char *sphere_tos(sphere s){
	
	char *string;
	char temp[100];
	sprintf(temp, "Center: {%lf, %lf, %lf}\nRadius: %lf\nShine: {%lf, %lf, %lf}", 
	s.center.x, s.center.y, s.center.z, s.radius, s.shine.r, s.shine.g, s.shine.b);
	string = strdup(temp);
	return string;
	free(string);
}

void sphere_show(FILE *f, sphere s){
	
	fprintf(f, "Center: {%lf, %lf, %lf}\nRadius: %lf\nShine: {%lf, %lf, %lf}", 
	s.center.x, s.center.y, s.center.z, s.radius, s.shine.r, s.shine.g, s.shine.b);
} 
 
======== stage.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - stage.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

char *stage_tos(stage stg){
	
	char *string;
	char temp[100];
	sprintf(temp, "%s\n%s", camera_tos(stg.c), scene_tos(stg.s));
	string = strdup(temp);
	return string;
	//free(string);
}

void stage_show(FILE *f, stage stg){
	
	fprintf(f, "%s\n%s", camera_tos(stg.c), scene_tos(stg.s));
}

stage get_stage(unsigned int selection){
	
		stage new_stage;
		new_stage.c.loc.x = 0.0;
		new_stage.c.loc.y = 0.0;
		new_stage.c.loc.z = -5.0;
		new_stage.c.h = 120;
		new_stage.c.w = 120;
		new_stage.s.bg.r = 0.0;
		new_stage.s.bg.g = 0.0;
		new_stage.s.bg.b = 0.25;
		object poster;
		poster.o.p.upper_left.x = -1.5;
		poster.o.p.upper_left.y = 1.5;
		poster.o.p.upper_left.z = 4.5;
		poster.o.p.w = 3.0;
		poster.o.p.h = 3.0;
		poster.o.p.surface_color = poster_red_distance;
		poster.tag = POSTER;
		new_stage.s.objects = ol_singleton(poster);
		return new_stage;
		
} 
 
======== xyz.c ========
/* Varshant Dhar, varshant
 * CS152, Winter 2016
 * Project A - xyz.c
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include "raytracer.h"

xyz xyz_expr(double x, double y, double z){
	
	xyz new_expr;
	new_expr.x = x;
	new_expr.y = y;
	new_expr.z = z;
	return new_expr;
	//free(new_expr);
}

xyz xyz_add(xyz v1, xyz v2){
	
	xyz add_xyz;
	add_xyz.x = v1.x + v2.x;
	add_xyz.y = v1.y + v2.y;
	add_xyz.z = v1.z + v2.z;
	return add_xyz;
	//free(add_xyz);
}

xyz xyz_sub(xyz v1, xyz v2){
	
	xyz v3;
	v3.x = v1.x - v2.x;
	v3.y = v1.y - v2.y;
	v3.z = v1.z - v2.z;
	return v3;
	//free(v3);
}

xyz xyz_neg(xyz v){
	
	xyz xyz_neg;
	xyz_neg.x = -v.x;
	xyz_neg.y = -v.y;
	xyz_neg.z = -v.z;
	return xyz_neg;
	//free(xyz_neg);
}

xyz xyz_scale(double s, xyz v){
	
	xyz xyz_scale;
	xyz_scale.x = s*v.x;
	xyz_scale.y = s*v.y;
	xyz_scale.z = s*v.z;
	return xyz_scale;
	//free(xyz_scale);
}

double xyz_dot(xyz v1, xyz v2){
	
	return (v1.x*v2.x)+(v1.y*v2.y)+(v1.z*v2.z);
}

double xyz_mag(xyz v){
	
	return sqrt(v.x*v.x+v.y*v.y+v.z*v.z);
}

xyz xyz_norm(xyz v){
		
	xyz xyz_norm;
	xyz_norm.x = v.x/xyz_mag(v);
	xyz_norm.y = v.y/xyz_mag(v);
	xyz_norm.z = v.z/xyz_mag(v);
	return xyz_norm;
	//free(xyz_norm);
}

char *xyz_tos(xyz v){
	
	char *string;
	char temp[100];
	sprintf(temp, "{%lf, %lf, %lf}", v.x, v.y, v.z);
	string = strdup(temp);
	return string;
	free(string);
}

void xyz_show(FILE *f, xyz v){
	
	fprintf(f, "{%lf, %lf, %lf}", v.x, v.y, v.z);
} 
 
